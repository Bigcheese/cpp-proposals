<!DOCTYPE html>
<html>
<head>
<meta charset="ASCII">
<style type="text/css">
body { color: #000000; background-color: #FFFFFF; }
del { text-decoration: line-through; color: #8B0040; }
ins { text-decoration: underline; color: #005100; }

p.example { margin-left: 2em; }
pre.example { margin-left: 2em; }
div.example { margin-left: 2em; }

code.extract { background-color: #F5F6A2; }
pre.extract { margin-left: 2em; background-color: #F5F6A2;
  border: 1px solid #E1E28E; }

p.function { }
.attribute { margin-left: 2em; }
.attribute dt { float: left; font-style: italic;
  padding-right: 1ex; }
.attribute dd { margin-left: 0em; }

blockquote.std { color: #000000; background-color: #F1F1F1;
  border: 1px solid #D1D1D1;
  padding-left: 0.5em; padding-right: 0.5em; }
blockquote.stddel { text-decoration: line-through;
  color: #000000; background-color: #FFEBFF;
  border: 1px solid #ECD7EC;
  padding-left: 0.5empadding-right: 0.5em; ; }

blockquote.stdins { text-decoration: underline;
  color: #000000; background-color: #C8FFC8;
  border: 1px solid #B3EBB3; padding: 0.5em; }

table { border: 1px solid black; border-spacing: 0px;
  margin-left: auto; margin-right: auto; }
th { text-align: left; vertical-align: top;
  padding-left: 0.8em; border: none; }
td { text-align: left; vertical-align: top;
  padding-left: 0.8em; border: none; }
</style>
<title>is_contiguous_layout</title>
</head>

<body>

<h1>is_contiguous_layout</h1>
<p>ISO/IEC JTC1 SC22 WG21 D???? = ??-???? - 2016-02-12
</p>
<address>Michael Spencer, bigcheesegs@gmail.com</address>

<section>
<h2 id="intro">Introduction</h2>
<p>This paper proposes adding a new compiler backed type trait to assist in
writing hash functions for user defined types.
</p>

<code>template &lt;class T&gt; struct is_contiguous_layout;</code>
</section>

<section>
<h2 id="motive">Motivation</h2>
<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0029r0.html">
P0029</a> proposes using the user defined trait
<code>is_uniquely_represented</code> to assert that a type can be hashed by
hashing its object representation. It states that
<code>is_uniquely_represented</code> can only be true for types which have no
padding, but intentionally avoids adding a type trait to check that to keep the
proposal a "pure library" proposal.
</p>

<p>It is not possible for users to portably assert that a type has the
<code>is_uniquely_represented</code> trait without compiler assistance.</p>

<h3 id="motive-trivial">Trivial Example</h3>
<pre><code>struct Trivial {
  char *Data;
  unsigned Len;
};
</code></pre>

<p>The contiguous hashibility of this type depends on:

<ol>
<li>The <code>sizeof</code> <code>Data</code>, <code>Len</code> and
<code>Trivial</code>. <code>sizeof(Data) + sizeof(Len)</code> must equal
<code>sizeof(Trivial)</code>.</li>
<li>The implementation defined mapping between pointer values and their object
representation.</li>
<li>The implementation defined mapping between unsigned values and their object
representation.</li>
</ol></p>

<p>1 can be checked via a static assert, however this is verbose.</p>

<p>2 and 3 can only be checked by reading the documentation for your
implementation, thus limiting portability. Although no implementation I know of
fails either of these.</p>

<h3 id="motive-bitfields">Bitfields</h3>
<pre><code>struct Bitfields {
  unsigned char A : 4;
  unsigned char B : 4;
  unsigned short C : 8;
};
</code></pre>

<p>The contiguous hashibility of this type depends on how bitfields are
implemented. And in practice is different between the Itanium ABI and Visual
C++. This can also only be checked by taking a look at the docs.</p>
</section>

<section>
<h2 id="sgfsesgesgsegsegsegsgsegsesgesegsegsegsegesg">Stuff</h2>
<p>The proposed wording for this trait is: </p>
<blockquote>
<p>A <var>contiguous-layout</var> type is a <var>standard-layout</var> type for
which all bits in the object representation participate in the value
representation (3.9).
</p>
</blockquote>
<p>This means that a standard-layout type is a contiguous-layout type unless
there exists two object representation bit patterns of the type for which there
exists no well defined program operating only on value types to observe the
difference.</p>

<h3 id="sgfsesgesgsegsegsegsgsegsesgesegsegsegsegesg-floats">Floats</h3>
<p>Floating point values may compare equal even when they have different object
representations. However this does not preclude them from having
contiguous-layout types, as equality is not the only way to observe the
difference between floating point values. The implementation may provide enough
observation tools to observe the full state of the value.</p>

<p>It is implementation defined if floating point types are contiguous-layout.
</p>

<h3 id="sgfsesgesgsegsegsegsgsegsesgesegsegsegsegesg-unions">Unions</h3>
<p>Unions with members which are all the same size and are all contiguous-layout
types are also obvious candidates for contiguous-layout types. However, unions
with members of different sizes present a problem, as the existence of padding
bytes depends on the runtime active member.</p>

<p>For incompatible union members, implementations are allowed to omit copying
the entire object representation of a union if it knows the active member. It is
completely reasonable for an implementation to do this if a member was just
assigned.</p>

<p>It is implementation defined if union types are contiguous-layout.</p>
</section>

<section>
<h2 id="std">Proposed Wording</h2>
<p>Proposed wording changes to the standard.
</p>

<h3>3.9 Types [basic.types]</h3>
<p>Add a new paragraph.
</p>
<blockquote class="stdins">
<p>A <var>contiguous-layout</var> type is a <var>standard-layout</var> type for
which all bits in the object representation participate in the value
representation (3.9).
</p>
</blockquote>

<h3>20.9.2 Header <code>&lt;type_traits&gt;</code> synopsis [meta.type.synop]</h3>
<p>Add to synopsis.
</p>
<blockquote class="stdins">
<code>template &lt;class T&gt; struct is_contiguous_layout;</code>
</blockquote>

<h3>20.9.4.3 Type properties [meta.unary.prop]</h3>
<p>Add to table 49 - Type property predicates.
</p>
<blockquote class="stdins">
<table is="cxx-table">
  <thead>
    <tr>
      <th>Template</th>
      <th>Condition</th>
      <th>Preconditions</th>
    </tr>
  </thead>
  <tr>
    <td><code>template &lt;class T&gt; struct is_contiguous_layout;</code></td>
    <td>T is a contiguous-layout type (3.9)</td>
    <td>T shall be a complete type, (possibly cv-qualified) void, or an array of unknown bound.</td>
  </tr>
</table>
</blockquote>
</section>

<section>
<h2 id="ref">References</h2>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0029r0.html">
P0029</a> - A Unified Proposal for Composable Hashing, Geoff Romer, Chandler Carruth</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3333.html">
N3333</a> - Hashing User-Defined Types in C++1y, Jeffrey Yasskin, Chandler Carruth</li>
</ul>
</section>

</body>
</html>
